#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     Autonomous_Switch, sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     rightMotor,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     Flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Arm,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     Lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    Gripper,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  // Standard joystick driver file from RobotC
#include "ExpoEquation.c"  // Function that performs the Exponential smoothing of the joystick inputs
// Define the following macros
#define DEADBAND(n,d)           ((abs(n) >= (d))? (n): 0)  //Set n to zero if < d where d = deadzone value
#define JOYSTICK_POWER(n)       expo(DEADBAND(n,5))
#define BOUND(n,low,high)       (((n) < (low))? (low): ((n) > (high))? (high): (n)) // low=-100 and high=100

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	clearDebugStream();
  return;
}

// Scale joysticks values
int scaleForMotor(int joyValue)
{
	const int DEADZONE = 5;
	const int MAX_MOTOR_VAL = 100;
	const float MAX_JOY_VAL = 127.0;

	if (abs(joyValue) < DEADZONE) {
		return 0;
	}
	// Otherwise scale joystick value
	int direction = joyValue / abs(joyValue);
	float ratio = (joyValue * joyValue) / (MAX_JOY_VAL * MAX_JOY_VAL);
	int scaledVal = ratio * MAX_MOTOR_VAL * direction;
	// return scaled value
	return scaledVal;
}

void arcade(int x, int y)
{
	int powY;
	int powRightMotor;
	int powLeftMotor;

	powY = y;
	if (x<0) //if x negative, turning left; otherwise, turning right
	{
		powLeftMotor = (powY * (128 + (2 * x))/128);  // left motor reduced in power for right turn
		powRightMotor = powY;
	}
	else
	{
		powRightMotor = (powY * (128 - (2 * x))/128);  // right motor reduced in power for left turn
		powLeftMotor = powY;
	}
	motor[leftMotor] = powLeftMotor;
	motor[rightMotor] = powRightMotor;
}

task drive()
{
    while (true){
        getJoystickSettings(joystick);
        // Scale the joystick x and y to the motor power range (-100 to 100) after applying deadband.
        //ArcadeDrive(JOYSTICK_POWER(joystick.joy1_y1), JOYSTICK_POWER(joystick.joy1_x1));
        arcade(scaleForMotor(joystick.joy1_x1),scaleForMotor(joystick.joy1_y1));
        wait1Msec(100);
    }
}

task main()
{
  initializeRobot();

  waitForStart(); // Wait for the beginning of TeleOp phase.

  StartTask(drive);  // give driver control of the wheels.  Using separate task so driver never loses control of bot.
  while (true)
  {
  	// Turn the flag motor
  	if(abs(joystick.joy2_x2) > 10) {
  		motor[Flag]=JOYSTICK_POWER(joystick.joy2_x2);	// Turn motor to raise the flag
  	} else {
  		motor[Flag]=0;
  	}

  	// Move the Arm
  	if(abs(joystick.joy2_y1) > 5) {
  		motor[Arm]=scaleForMotor(joystick.joy2_y1); // Move the Arm using expo control
  	} else {
  		motor[Arm]=0;
  	}
  	// Move the Lift up
  	while(joystick.joy2_TopHat == 0)      // if the topmost button on joy2's D-Pad ('TopHat') is pressed:
    {
    	motor[Lift] = 50;                // Raise the lifting arm at 50% power
    }

  	// Move the Lift down and raise the Robot, without burning up the motor!!
    ClearTimer(T1);  // Use Timer T1 to limit motor for safety
    while(joystick.joy2_TopHat == 4 && time1[T1] < 2000)  // if the bottom button on joy2's D-Pad is pressed && T1<3500:
    {
  		motor[Lift]=-100;  // Lower lift arm at 100% motor drive for lifting heavy bot
  	}
  	motor[Lift]=0;  // Brake for lift motor

  	if(joy2Btn(5) == 1)			// if Button 5 is pressed on joy2:
  	{
    	servo[Gripper] = 150;   // Move Gripper to open position
  	}
		if(joy2Btn(6) == 1)     // if Button 6 is pressed on joy2:
  	{
    	servo[Gripper] = 110;   // Move Gripper to closed position
  	}
  }
}

/*
void ArcadeDrive(int drivePower, int turnPower)
{
  writeDebugStreamLine("Joy1_X1 is: %d", joystick.joy1_x1);
  writeDebugStreamLine("Joy1_Y1 is: %d", joystick.joy1_y1);
	writeDebugStreamLine("drivePower is: %d", drivePower);
  writeDebugStreamLine("turnPower is: %d", turnPower);
  if(drivePower >= 5 && turnPower >= 5) {
  	motor[leftMotor] = 100;
  	motor[rightMotor] = drivePower;
  }
  if(drivePower >= 5 && turnPower <= -5) {
  	motor[rightMotor] = 100;
  	motor[leftMotor] = drivePower;
  }
  if(drivePower <= -5 && turnPower >= 5) {
  	motor[leftMotor] = -100;
  	motor[rightMotor] = -drivePower;
  }
  if(drivePower <= -5 && turnPower <= -5) {
  	motor[rightMotor] = -100;
  	motor[leftMotor] = -drivePower;
  }
  	//motor[leftMotor] = BOUND(drivePower + turnPower, -100, 100);
  //writeDebugStreamLine("leftMotor is: %d", motor[leftMotor]);
	//motor[rightMotor] = BOUND(drivePower - turnPower, -100, 100);
	//writeDebugStreamLine("rightMotor is: %d", motor[rightMotor]);
}
*/
