#pragma config(Sensor, S1,     turnSensor,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S2,     sonarSensor,          sensorSONAR)
#pragma config(Motor,  motorA,          rightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void turnRobot(int Power, int degreesToTurn) {
	// take initial reading from gyro
	float degreesSoFar = 0;
	int initialTurnReading = SensorValue[turnSensor];
	// start turning
	motor[rightMotor] = -Power * sgn(degreesToTurn);
	motor[leftMotor] = Power * sgn(degreesToTurn);
	// check if we have turned enough
	while (abs(degreesSoFar) < abs(degreesToTurn)) // Use absolute value so this works for negative degreesToTurn
	{
		// update degreesSoFar
		wait1Msec(10);  // wait 10 milliseconds or .01 seconds
		int currentGyroReading = SensorValue[turnSensor] - initialTurnReading;
		degreesSoFar = degreesSoFar + currentGyroReading * .01;
	}
	// stop turning
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

task main()
{

	int distance_in_cm = 30;   // Create variable 'distance_in_cm' and initialize it to 30(cm)
	int i = 0;

	for (i=0; i<4; i++)  // Drive robot until it gets close to 4 things
	{

		while(SensorValue[sonarSensor] > distance_in_cm)   // While the Sonar Sensor readings are less than the specified, 'distance_in_cm':
		{
			motor[rightMotor] = 75;
			motor[leftMotor] = 75;
		}
		motor[rightMotor] = 0;
		motor[leftMotor] = 0;

		// turn around if obsticle detected

		turnRobot(25,180);  // First number is motor power; second number is degrees

	}

}
